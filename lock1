-- Create a temporary table for wait type descriptions
CREATE TABLE #WaitTypeDescriptions (
    wait_type VARCHAR(60) PRIMARY KEY,
    description VARCHAR(255)
);

-- Insert common wait types and their descriptions
INSERT INTO #WaitTypeDescriptions (wait_type, description)
VALUES
    -- [Add all the wait types as before]
    ('LCK_M_S', 'Waiting to acquire a shared lock'),
    ('LCK_M_U', 'Waiting to acquire an update lock'),
    ('LCK_M_X', 'Waiting to acquire an exclusive lock'),
    -- [Include all other wait types]
    ('OTHER', 'Other wait types');

WITH cte_blocking_sessions AS (
    -- Anchor member: sessions that are blocking others but are not themselves blocked
    SELECT 
        bs.session_id,
        CAST(0 AS SMALLINT) AS blocking_session_id,
        bs.sql_handle,
        0 AS execution_level,
        bs.session_id AS ordering,
        bs.wait_type,
        bs.wait_time,
        bs.wait_resource
    FROM 
        (
            -- Sessions that are blocking others but are not themselves blocked
            SELECT 
                s.session_id,
                ISNULL(r.sql_handle, c.most_recent_sql_handle) AS sql_handle,
                r.wait_type,
                r.wait_time,
                r.wait_resource
            FROM 
                sys.dm_exec_sessions s
            LEFT JOIN 
                sys.dm_exec_requests r ON s.session_id = r.session_id
            LEFT JOIN 
                sys.dm_exec_connections c ON s.session_id = c.session_id
            WHERE 
                s.is_user_process = 1
                AND s.session_id IN (
                    SELECT blocking_session_id
                    FROM sys.dm_exec_requests
                    WHERE blocking_session_id <> 0
                )
                AND s.session_id NOT IN (
                    SELECT session_id
                    FROM sys.dm_exec_requests
                    WHERE blocking_session_id <> 0
                )
        ) bs

    UNION ALL

    -- Recursive member: sessions that are blocked by others
    SELECT 
        br.session_id,
        br.blocking_session_id,
        br.sql_handle,
        cte.execution_level + 1,
        cte.ordering,
        br.wait_type,
        br.wait_time,
        br.wait_resource
    FROM 
        sys.dm_exec_requests br
    INNER JOIN 
        cte_blocking_sessions cte ON br.blocking_session_id = cte.session_id
)
SELECT DISTINCT 
    -- Indentation to represent the blocking hierarchy
    REPLICATE(' ', cte.execution_level * 4) + '|-' + CAST(cte.session_id AS VARCHAR(5)) AS session_id,
    txt.text AS sql_text,
    cte.blocking_session_id,
    cte.execution_level,
    cte.ordering, -- Included to fix ORDER BY error
    cte.wait_type,
    -- Include wait type description
    ISNULL(wtd.description, 'Unknown wait type') AS wait_type_description,
    -- Format wait_time in hh:mm:ss
    RIGHT('0' + CAST(cte.wait_time / 1000 / 3600 AS VARCHAR), 2) + ':' +
    RIGHT('0' + CAST((cte.wait_time / 1000 / 60) % 60 AS VARCHAR), 2) + ':' +
    RIGHT('0' + CAST((cte.wait_time / 1000) % 60 AS VARCHAR), 2) AS wait_time_formatted,
    cte.wait_resource,
    -- Resource description based on wait_resource
    rd.resource_description,
    -- Object details from sys.dm_tran_locks and sys.objects
    DB_NAME(tl.resource_database_id) AS database_name,
    s.name AS schema_name,
    o.name AS object_name,
    i.name AS index_name,
    ses.login_name,
    ses.status,
    ses.host_name,
    ses.program_name,
    ses.last_request_start_time,
    ses.last_request_end_time,
    req.command,
    -- Map transaction_isolation_level to names
    CASE req.transaction_isolation_level
        WHEN 0 THEN 'Unspecified'
        WHEN 1 THEN 'Read Uncommitted'
        WHEN 2 THEN 'Read Committed'
        WHEN 3 THEN 'Repeatable Read'
        WHEN 4 THEN 'Serializable'
        WHEN 5 THEN 'Snapshot'
        ELSE 'Unknown'
    END AS transaction_isolation_level_desc
FROM 
    cte_blocking_sessions cte
LEFT JOIN
    sys.dm_exec_sessions ses ON cte.session_id = ses.session_id
LEFT JOIN
    sys.dm_exec_requests req ON cte.session_id = req.session_id
CROSS APPLY 
    sys.dm_exec_sql_text(cte.sql_handle) AS txt
LEFT JOIN
    #WaitTypeDescriptions wtd ON cte.wait_type = wtd.wait_type
-- Join with sys.dm_tran_locks to get object details
LEFT JOIN (
    SELECT DISTINCT
        request_session_id,
        resource_type AS lock_resource_type,
        resource_database_id,
        resource_associated_entity_id
    FROM sys.dm_tran_locks
) tl ON cte.session_id = tl.request_session_id
LEFT JOIN
    sys.objects o ON tl.resource_associated_entity_id = o.object_id
LEFT JOIN
    sys.schemas s ON o.schema_id = s.schema_id
LEFT JOIN
    sys.indexes i ON o.object_id = i.object_id AND tl.lock_resource_type IN ('KEY', 'INDEX')
-- Use a CROSS APPLY to parse wait_resource and extract additional info
CROSS APPLY (
    SELECT 
        CASE 
            WHEN cte.wait_resource LIKE 'KEY: %' THEN 'Waiting for a lock on an index key'
            WHEN cte.wait_resource LIKE 'PAGE: %' THEN 'Waiting for a lock on a data or index page'
            WHEN cte.wait_resource LIKE 'OBJECT: %' THEN 'Waiting for a lock on an entire object'
            WHEN cte.wait_resource LIKE 'RID: %' THEN 'Waiting for a lock on a row in a heap'
            ELSE 'Waiting for a resource'
        END AS resource_description
) rd
ORDER BY 
    cte.ordering, cte.execution_level;

-- Drop the temporary table after use
DROP TABLE #WaitTypeDescriptions;
