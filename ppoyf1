# Install required packages
!pip install stable-baselines3 gymnasium yfinance ta matplotlib seaborn torch scikit-learn optuna

import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pandas as pd
import yfinance as yf
from ta import trend, momentum, volatility, volume
import matplotlib.pyplot as plt
import seaborn as sns
from stable_baselines3 import PPO
from stable_baselines3.common.env_checker import check_env
from stable_baselines3.common.vec_env import DummyVecEnv
import torch
import warnings
from typing import Optional
import random
import datetime
from sklearn.preprocessing import StandardScaler
import math
import time
import logging
from pathlib import Path

warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

RANDOM_SEED = 42
random.seed(RANDOM_SEED)
np.random.seed(RANDOM_SEED)
torch.manual_seed(RANDOM_SEED)

BASE_DIR = Path('.').resolve()
RESULTS_DIR = BASE_DIR / 'results'
PLOTS_DIR = BASE_DIR / 'plots'
RESULTS_DIR.mkdir(parents=True, exist_ok=True)
PLOTS_DIR.mkdir(parents=True, exist_ok=True)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

##############################################
# Fetch and Prepare Data
##############################################

def get_data(ticker: str, start_date: str, end_date: str) -> pd.DataFrame:
    df = yf.download(ticker, start=start_date, end=end_date, progress=False)
    if df.empty:
        logging.error(f"No data fetched for {ticker}")
        return df

    # Flatten MultiIndex columns if necessary
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = [' '.join(col).strip() for col in df.columns.values]
        logging.info(f"Flattened MultiIndex columns: {df.columns}")

    # Remove ticker suffix from column names
    ticker_suffix = f' {ticker}'
    df.columns = [col.replace(ticker_suffix, '') if col.endswith(ticker_suffix) else col for col in df.columns]

    required_columns = ['Close', 'High', 'Low', 'Volume']
    for col in required_columns:
        if col not in df.columns:
            logging.error(f"{col} not in downloaded data for {ticker}. Data columns: {df.columns}")
            return pd.DataFrame()

    # Check if data length sufficient
    if len(df) < 200:
        logging.error(f"Not enough data points for {ticker}.")
        return pd.DataFrame()

    close_col = 'Close'
    # Calculate indicators
    try:
        # Ensure that the columns are 1-dimensional pandas Series
        close = df[close_col].squeeze()
        high = df['High'].squeeze()
        low = df['Low'].squeeze()
        volume_col = df['Volume'].squeeze()

        sma10 = trend.SMAIndicator(close=close, window=10).sma_indicator()
        sma50 = trend.SMAIndicator(close=close, window=50).sma_indicator()
        rsi = momentum.RSIIndicator(close=close, window=14).rsi()
        macd = trend.MACD(close=close).macd()
        adx = trend.ADXIndicator(high=high, low=low, close=close, window=14).adx()
        bollinger = volatility.BollingerBands(close=close, window=20, window_dev=2)
        bb_upper = bollinger.bollinger_hband()
        bb_lower = bollinger.bollinger_lband()
        bollinger_width = bollinger.bollinger_wband()
        ema20 = trend.EMAIndicator(close=close, window=20).ema_indicator()
        vwap = volume.VolumeWeightedAveragePrice(high=high, low=low, close=close, volume=volume_col, window=14).volume_weighted_average_price()
        lagged_return = close.pct_change().fillna(0)
        atr = volatility.AverageTrueRange(high=high, low=low, close=close, window=14).average_true_range()
    except Exception as e:
        logging.error(f"Error calculating indicators for {ticker}: {e}")
        logging.debug(f"DataFrame columns: {df.columns}")
        logging.debug(f"DataFrame head:\n{df.head()}")
        return pd.DataFrame()

    df['SMA10'] = sma10
    df['SMA50'] = sma50
    df['RSI'] = rsi
    df['MACD'] = macd
    df['ADX'] = adx
    df['BB_Upper'] = bb_upper
    df['BB_Lower'] = bb_lower
    df['Bollinger_Width'] = bollinger_width
    df['EMA20'] = ema20
    df['VWAP'] = vwap
    df['Lagged_Return'] = lagged_return
    df['Volatility'] = atr

    df.fillna(method='ffill', inplace=True)
    df.fillna(0, inplace=True)
    df.reset_index(inplace=True)
    df['Close_unscaled'] = df['Close']

    features = ['Close', 'SMA10', 'SMA50', 'RSI', 'MACD', 'ADX',
                'BB_Upper', 'BB_Lower', 'Bollinger_Width', 'EMA20',
                'VWAP', 'Lagged_Return', 'Volatility']
    if (df[features].std() == 0).any():
        logging.error(f"One or more features have zero variance for {ticker}.")
        return pd.DataFrame()

    scaler = StandardScaler()
    df[features] = scaler.fit_transform(df[features])

    return df

##############################################
# Custom Trading Environment
##############################################

class SingleStockTradingEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, df: pd.DataFrame, initial_balance: float = 100000, 
                 stop_loss: float = 0.90, take_profit: float = 1.10, 
                 max_position_size: float = 0.25, max_drawdown: float = 0.20,
                 annual_trading_days: int = 252):
        super(SingleStockTradingEnv, self).__init__()

        self.df = df.copy().reset_index(drop=True)
        self.initial_balance = initial_balance
        self.current_step = 0
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.max_position_size = max_position_size
        self.max_drawdown = max_drawdown
        self.annual_trading_days = annual_trading_days

        # Action space: 2D action [-1,1] for buy fraction and [-1,1] for sell fraction
        self.action_space = spaces.Box(low=-1, high=1, shape=(2,), dtype=np.float32)

        self.num_features = 13
        self.market_phase = ['Bull', 'Bear', 'Sideways']
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf,
                                            shape=(self.num_features + 3 + len(self.market_phase),),
                                            dtype=np.float32)

        self.feature_names = ['Close', 'SMA10', 'SMA50', 'RSI', 'MACD', 'ADX',
                              'BB_Upper', 'BB_Lower', 'Bollinger_Width', 'EMA20',
                              'VWAP', 'Lagged_Return', 'Volatility']

        self.reset()

    def _next_observation(self) -> np.ndarray:
        if self.current_step >= len(self.df):
            self.current_step = len(self.df) - 1
        current_data = self.df.iloc[self.current_step]
        features = current_data[self.feature_names].values
        obs = list(features)

        obs.append(self.balance / self.initial_balance)
        obs.append(self.net_worth / self.initial_balance)
        obs.append(self.position / self.initial_balance)

        adx = current_data['ADX']
        if adx > 25:
            if current_data['SMA10'] > current_data['SMA50']:
                phase = 'Bull'
            else:
                phase = 'Bear'
        else:
            phase = 'Sideways'

        for p in self.market_phase:
            obs.append(1.0 if phase == p else 0.0)

        obs = np.array(obs, dtype=np.float32)
        if np.isnan(obs).any() or np.isinf(obs).any():
            obs = np.nan_to_num(obs, nan=0.0, posinf=0.0, neginf=0.0)
        return obs

    def step(self, actions: np.ndarray):
        current_data = self.df.iloc[self.current_step]
        terminated = False
        truncated = False

        current_price = current_data['Close_unscaled']
        actions = np.clip(actions, -1, 1)
        buy_fraction = max(actions[0], 0)
        sell_fraction = max(actions[1], 0)

        # Adaptive position sizing (simple): just scale by max_position_size
        adaptive_size = self.max_position_size
        max_buy = (adaptive_size * self.net_worth) / current_price
        shares_to_buy = math.floor(buy_fraction * max_buy)
        buy_signal_price = np.nan
        if shares_to_buy > 0 and self.balance >= shares_to_buy * current_price:
            self.balance -= shares_to_buy * current_price
            self.position += shares_to_buy
            self.total_buy_cost += shares_to_buy * current_price
            buy_signal_price = current_price

        max_sell = self.position * adaptive_size
        shares_to_sell = min(math.floor(sell_fraction * max_sell), self.position)
        sell_signal_price = np.nan
        if shares_to_sell > 0:
            self.balance += shares_to_sell * current_price
            self.position -= shares_to_sell
            self.total_shares_sold += shares_to_sell
            self.total_sales_value += shares_to_sell * current_price
            sell_signal_price = current_price

        self.net_worth = self.balance + self.position * current_price
        reward = self.net_worth - self.prev_net_worth

        self.peak = max(self.peak, self.net_worth)
        drawdown = (self.net_worth - self.peak) / self.peak
        if drawdown < -self.max_drawdown:
            reward -= 100
            terminated = True

        if self.position > 0:
            avg_buy_price = self.total_buy_cost / self.position if self.position > 0 else 0
            price_change = current_price / avg_buy_price if avg_buy_price > 0 else 1.0
            if price_change <= self.stop_loss:
                self.balance += self.position * current_price
                reward -= self.position * avg_buy_price * (1 - self.stop_loss)
                self.position = 0
                terminated = True
            elif price_change >= self.take_profit:
                self.balance += self.position * current_price
                reward += self.position * avg_buy_price * (self.take_profit - 1)
                self.position = 0
                terminated = True

        self.prev_net_worth = self.net_worth

        if self.net_worth <= 0:
            reward -= 1000
            terminated = True
            truncated = True

        self.history.append({
            'Step': self.current_step,
            'Date': current_data['Date'],
            'Balance': self.balance,
            'Position': self.position,
            'Net Worth': self.net_worth,
            'Reward': reward,
            'Buy_Signal_Price': buy_signal_price,
            'Sell_Signal_Price': sell_signal_price
        })

        self.current_step += 1
        if self.current_step >= len(self.df)-1:
            terminated = True

        obs = np.zeros(self.observation_space.shape, dtype=np.float32)
        if not terminated and not truncated:
            obs = self._next_observation()

        info = {}
        return obs, reward, terminated, truncated, info

    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        super().reset(seed=seed)
        self.balance = self.initial_balance
        self.position = 0
        self.net_worth = self.initial_balance
        self.prev_net_worth = self.initial_balance
        self.peak = self.initial_balance
        self.total_buy_cost = 0
        self.total_shares_sold = 0
        self.total_sales_value = 0
        self.current_step = 0
        self.history = []
        obs = self._next_observation()
        info = {}
        return obs, info

    def render(self, mode='human', close=False):
        profit = self.net_worth - self.initial_balance
        print(f'Step: {self.current_step}, Balance: {self.balance:.2f}, Position: {self.position}, Net Worth: {self.net_worth:.2f}, Profit: {profit:.2f}')

##############################################
# Baseline Strategy (Buy and Hold)
##############################################

def calculate_max_drawdown(net_worth_series: pd.Series) -> float:
    rolling_max = net_worth_series.cummax()
    drawdown = (net_worth_series - rolling_max)/rolling_max
    return drawdown.min()

def buy_and_hold(df: pd.DataFrame, ticker: str, initial_balance: float = 100000) -> dict:
    buy_price = df.iloc[0]['Close_unscaled']
    shares_bought = math.floor(initial_balance / buy_price)
    balance = initial_balance - shares_bought * buy_price
    net_worth_series = []
    for _, row in df.iterrows():
        nw = balance + shares_bought * row['Close_unscaled']
        net_worth_series.append(nw)
    final_net_worth = net_worth_series[-1]
    profit = final_net_worth - initial_balance
    max_dd = calculate_max_drawdown(pd.Series(net_worth_series))
    return {
        'Strategy': 'Buy and Hold',
        'Ticker': ticker,
        'Initial Balance': initial_balance,
        'Final Net Worth': final_net_worth,
        'Profit': profit,
        'Max Drawdown': max_dd
    }

def plot_results(df: pd.DataFrame, rl_df: pd.DataFrame, ticker: str):
    plt.figure(figsize=(14,7))
    plt.plot(df['Date'], df['Close_unscaled'], label='Close Price')
    buy_points = rl_df[rl_df['Buy_Signal_Price'].notna()]
    sell_points = rl_df[rl_df['Sell_Signal_Price'].notna()]
    plt.scatter(buy_points['Date'], buy_points['Buy_Signal_Price'], marker='^', color='green', s=100, label='Buy')
    plt.scatter(sell_points['Date'], sell_points['Sell_Signal_Price'], marker='v', color='red', s=100, label='Sell')
    plt.title(f"{ticker} Price with Trades")
    plt.legend()
    plt.grid(True)
    plt.show()

    plt.figure(figsize=(14,7))
    plt.plot(rl_df['Date'], rl_df['Net Worth'], label='Net Worth')
    plt.title(f"{ticker} RL Agent Net Worth Over Time")
    plt.legend()
    plt.grid(True)
    plt.show()

##############################################
# Main Execution
##############################################

if __name__ == "__main__":
    TICKER = 'APOLLOTYRE.NS'  # Change to 'AAPL' for testing
    START_DATE = '2018-01-01'
    END_DATE = datetime.datetime.now().strftime('%Y-%m-%d')  # Updated to current date
    INITIAL_BALANCE = 100000

    # Fetch data
    df = get_data(TICKER, START_DATE, END_DATE)
    if df.empty:
        print("No data. Exiting.")
        exit()

    print(f"DataFrame columns after processing: {df.columns}")
    print(df.head())

    # Split into train/test
    split_idx = int(len(df)*0.8)
    train_df = df.iloc[:split_idx].reset_index(drop=True)
    test_df = df.iloc[split_idx:].reset_index(drop=True)

    # Create environment and check
    env = SingleStockTradingEnv(train_df, initial_balance=INITIAL_BALANCE)
    check_env(env, warn=True)

    # Train PPO agent
    vec_env = DummyVecEnv([lambda: env])
    model = PPO('MlpPolicy', vec_env, verbose=1, seed=RANDOM_SEED, learning_rate=3e-4)
    model.learn(total_timesteps=20000)
    model.save("ppo_model_apollotyre")

    # Test the trained model
    test_env = SingleStockTradingEnv(test_df, initial_balance=INITIAL_BALANCE)
    test_vec_env = DummyVecEnv([lambda: test_env])

    obs = test_vec_env.reset()  # Corrected reset
    done = False
    rl_history = []
    while not done:
        action, _ = model.predict(obs, deterministic=True)
        obs, rewards, dones, infos = test_vec_env.step(action)  # Corrected step
        done = dones[0]  # Assuming single environment
        if test_env.history:
            rl_history.append(test_env.history[-1])

    rl_df = pd.DataFrame(rl_history)
    rl_df['Date'] = pd.to_datetime(rl_df['Date'])
    rl_net_worth = rl_df['Net Worth']
    rl_final_net_worth = rl_net_worth.iloc[-1]
    rl_profit = rl_final_net_worth - INITIAL_BALANCE
    rl_max_dd = calculate_max_drawdown(rl_net_worth)

    # Baseline
    bh_result = buy_and_hold(test_df, TICKER, INITIAL_BALANCE)

    # Print Results
    print("Buy and Hold Performance:")
    print(f"  Final Net Worth: {bh_result['Final Net Worth']:.2f}, Profit: {bh_result['Profit']:.2f}, Max DD: {bh_result['Max Drawdown']:.2f}")

    print("RL Agent Performance:")
    print(f"  Final Net Worth: {rl_final_net_worth:.2f}, Profit: {rl_profit:.2f}, Max DD: {rl_max_dd:.2f}")

    # Plot Results
    plot_results(test_df, rl_df, TICKER)
